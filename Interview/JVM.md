## JVM

#### 内存模型
- Heap：Java堆是可供各线程共享的运行时内存区域，是Java虚拟机所管理的内存区域中最大的一块。
- Methoad Area：方法区的数据由所有线程共享，因此为安全的使用方法区的数据，需要注意线程安全问题。
- Stack：对于每个JVM线程，当线程启动时，都会分配一个独立的运行时栈，用以保存方法调用。
- PC Register：对于每个 JVM 线程，当线程启动时，都会有一个独立的 PC（Program Counter） 计数器，用来保存当前执行的代码地址（方法区中的内存地址）。
- Native Method Stack：本地方法栈和 Java 虚拟机栈的作用相似，Java 虚拟机栈执行的是字节码，而本地方法栈执行的是 native 方法。本地方法栈使用传统的栈（C Stack）来支持 native 方法。
- Direct Memory：在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为 避免了在 Java 堆和 Native 堆中来回复制数据。

#### 垃圾回收
- 引用计数算法：引用计数算法是判断对象是否存活的基本算法：给每个对象添加一个引用计数器，没当一个地方引用它的时候，计数器值加1；当引用失效后，计数器值减1。但是这种方法有一个致命的缺陷，当两个对象相互引用时会导致这两个都无法被回收。
- 根搜索算法：根搜索算法实际上是追踪从根结点GC Root开始的引用图。

#### 垃圾回收算法
- 复制回收算法：将可用内存分为大小相等的两份，在同一时刻只使用其中的一份。当这一份内存使用完了，就将还存活的对象复制到另一份上，然后将这一份上的内存清空。复制算法能有效避免内存碎片，但是算法需要将内存一分为二，导致内存使用率大大降低。
- 标记清除算法：先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后，恢复运行线程。标记清除后会产生大量不连续的内存碎片，造成空间浪费。
- 标记整理算法：和标记清除相似，不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而集成空闲空间。
- 增量回收：需要程序将所拥有的内存空间分成若干分区（Region）。程序运行所需的存储对象会分布在这些分区中，每次只对其中一个分区进行回收操作，从而避免程序全部运行线程暂停来进行回收，允许部分线程在不影响回收行为而保持运行，并且降低回收时间，增加程序响应速度。
- 分代回收：在 JVM 中不同的对象拥有不同的生命周期，因此对于不同生命周期的对象也可以采用不同的垃圾回收算法，以提高效率，这就是分代回收算法的核心思想。

#### 类加载
> 负责动态加载Java类到Java 虚拟机的内存空间中。  
> 类通常是按需加载，即第一次使用该类时才加载。   
> 每个Java类必须由某个类加载器装入到内存。  
Java语言系统自带有三个类加载器:
- **Bootstrap ClassLoader**：最顶层的加载类，主要加载核心类库。通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。  
- **Extention ClassLoader**：扩展的类加载器。
- **Appclass Loader**：也称为SystemAppClass 加载当前应用的classpath的所有类。

加载顺序

``` Bootstrap CLassloder -> Extention ClassLoader -> AppClassLoader ```


#### Dalvik、ART虚拟机

> Dalvik：是依靠一个Just-In-Time(JIT)编译器去解释字节码，让应用更容易在不同硬件和架构上运行。每次运行应用都需要编译，程序的执行效率低。  
> ART:（Android Runtime, Android4.4新增）  
> ART在应用安装的时候就预先编译字节码，转换为机械语言存储在本地，这一机制叫Ahead-Of-Time(AOT)编译。应用执行更有效率，启动更快。  

ART优点：
- 系统性能的显著提升
- 应用启动更快、运行更快、体验更流畅、触感反馈更及时
- 更长的电池续航能力
- 支持更低的硬件

ART缺点：
- 更大的存储空间占用，可能会增加10%-20%
- 更长的应用安装时间
