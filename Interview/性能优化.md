## 性能优化

#### 启动优化
 - `Application/Activity`的`onCreate`方法尽量做更少的事情
 - 耗时初始化业务异步或`IntentService`执行
 - 懒加载，使用时再进行初始化
  
#### UI布局优化
 - 主线程不做耗时操作
 - 复杂布局层级优化
 - 同一时间动画执行的次数过多
 - `View`过度绘制、频繁触发`measure、layout`
 - `onDraw`方法尽量少创建对象、不执行耗时操作、少使用循环
 - `include`标签：解决重复定义相同布局的问题
 - `ViewStub`标签：需要时/延迟加载。默认不可见，通过setVisibility或者Inflate函数进行加载
 - `merge`标签：减少布局的层级。配合include标签使用时，根ViewGroup可以替换为merge

#### 图片优化
 - 图片压缩、裁剪处理
 - 降低图片编码格式
 - 使用更优的图片格式`WebP`（4.0+，4.0以下系统需要使用第三方库进行适配）
 - 使用第三方库优化图片加载（`Glide、Fresco`）

#### 内存泄漏优化
 - `Context`使用不当造成内存泄露
 - 非静态内部类的静态实例容易造成内存泄漏
 - 线程未终止造成的内存泄露
 - 服务的注册、解除注册没有成对出现造成的内存泄露
 - `Cursor、WebView、IO流`等对象未关闭导致的内存泄漏

#### OOM优化
 - 不要加载过大的`Bitmap`对象
 - 复用`convertView`，使用`ViewHolder`
 - 列表等操作中只加载可见区域的图像、滑动时不加载图像
 - `onLowMemory()`和`onTrimMemory()`释放资源
 - 大内存分配等可疑内存操作时进行`try catch`操作
 - 分页加载
 - `RecyclerView`使用`DiffUtil`进行高效刷新
 - 使用系统优化过的数据集合：`ArrayMap、SparseArray、SparseBooleanArray、LongSparseArray`（效率高、内存占用少、避免了自动装箱和拆箱）

#### 电量优化
 - 对定位要求不太高的场景尽量使用网络定位
 - 减少网络请求次数
 - 后台任务要尽可能少的唤醒CPU
 - 通过`PowerManager.WakeLock、JobScheduler`来控制一些逻辑操作达到省电优化
 - 对于定时任务尽量使用`AlarmManager`，而不是`sleep、Timer`

#### 内存策略优化
 - 谨慎使用large heap
 - 综合考虑设备内存阈值与其他因素设计合适的缓存大小
 - `onLowMemory()`：当所有的后台应用都被kill掉的时候，前台应用会收到`onLowMemory()`的回调。在这种情况下，需要尽快释放当前应用的非必须的内存资源，从而确保系统能够继续稳定运行。
 - `onTrimMemory(int)`：Android系统从4.0开始还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调。
 收到onTrimMemory()回调的时候，需要根据传递的参数类型进行判断，合理的选择释放自身的一些内存占用，一方面可以提高系统的整体运行流畅度，另外也可以避免自己被系统判断为优先需要杀掉的应用。
 。`Android 4.0`以下的版本，你可以使用`onLowMemory()`回调来进行兼容。
 - 资源文件需要选择合适的文件夹进行存放

#### 优化工具
 - 使用`HierarchyViewer`分析UI性能
 - 使用GPU过度绘制分析UI性能
 - 使用GPU呈现模式图及FPS考核UI性能
 - 使用`Lint`进行资源及冗余UI布局等优化
 - 使用`Memory`监测及GC打印与`Allocation Tracker`进行UI卡顿分析
 - 使用`Traceview、dmtracedump`进行分析优化
 - 使用`Systrace`进行分析优化
 - 使用`traces.txt`文件进行ANR分析优化
 - 使用`LeakCanary、MAT`工具定位分析内存泄漏
 - 使用`BlockCanary`定位卡顿信息
 - 使用`Lint、FindBugs`定位项目中潜在的问题或错误
