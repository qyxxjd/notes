#### 面向对象的基本思想
- 封装、继承、多态
- 单一职责原则：一个类只做一件事情/一个类应该仅有一个引起它变化的原因
- 开放封闭原则：对扩展开放, 对更改封闭
- 里氏替换原则：面向接口编程, 使用子类来替换父类
- 依赖倒置原则：高层模块不要依赖低层模块
- 接口隔离原则：多个专用接口优于一个单一的接口

#### Object关键函数
- getClass()：返回该对象运行时的class对象，返回的 Class 对象是由所表示的类的静态同步方法锁定的对象。
- hashCode()：返回该对象的hashcode，该方法对hash表提供支持。如果两个对象根据 equals 方法认为是相等的，那么这两个对象也应该返回相等的 hashcode。
- equals()：判定两个对象是否相等。equals和hashCode需要同时被overwrite
- clone()：创建一个该对象的副本
- toString()：以文本形式展示该对象
- finalize()：当 GC 认为该对象已经没有任何引用的时候，该方法被GC收集器调用。子类可以 overwrite 该方法来关闭系统资源或者其他清理任务。
- wait()：当前线程等待知道其他线程调用该对象的 notify 或者 notifyAll方法。当前线程必须拥有该对象的 monitor。
- notify()：唤醒一个等待在该对象monitor上的线程。
- notifyAll()：唤醒所有等待在该对象monitor上的线程。

####  IO
- 字节流：`InputStream、OutputStream`，字节流可处理任何类型的对象，包括二进制对象，但不能直接处理Unicode字符。
- 字符流：`Reader、Writer`，字符流只能处理字符或者字符串。
- BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。适用于连接数目比较小且固定的场景。
- NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。适用于连接数目多且连接比较短（轻操作）的场景。
- AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。适用于连接数目多且连接比较长（重操作）的场景。

#### 反射
> 在运行时动态加载类或调用方法/访问属性，它不需要事先知道运行对象是谁。  
- 在运行时判断任意一个对象所属的类；
- 在运行时构造任意一个类的对象；
- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
- 在运行时调用任意一个对象的方法。

Class对象是Java反射的基础，它包含了与类相关的信息，Class对象就是用来创建类的所有对象的。  
- 通过实例变量的 getClass() 方法。`Class clazz = xxx.getClass();`
- 通过 Class 类的静态方法 forName() 方法。`Class clazz = Class.forName("xxx");`
- 使用类常量或 TYPE 字段。`Class<Integer> intClass = int.class; Class<Integer> integerType = Integer.TYPE;`


#### HashMap和HashTable区别
- HashTable
    - 线程安全
    - key不允许为空
    - 继承Dictionary抽象类，实现Map接口
    - 底层实现 `数组+链表`
    - 计算hash：使用key的hashcode对table数组的长度直接进行取模

- HashMap
    - 非线程安全
    - key允许空，以null作为key时，总是存储在table数组的第一个节点上
    - 继承AbstractMap抽象类，实现Map接口
    - 底层实现 `数组+链表`
    - 计算hash：对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模
    
- ConcurrentHashMap
    - 线程安全
    - key、value都不允许为空
    - 继承AbstractMap抽象类，实现ConcurrentMap接口


#### Java中堆和栈的区别？
- 堆内存：用来存放运行时创建的对象；由Java虚拟机的自动垃圾回收器来管理。
    - 优势：可以动态地分配内存大小
    - 劣势：存取速度较慢
- 栈内存：主要用来存放基本数据类型、局部变量常量、对象实例的引用地址；当超过变量的作用域后内存就会被自动释放掉。
    - 优势：存取速度比堆要快，仅次于寄存器，栈数据可以共享。
    - 缺点：存在栈中的数据大小、生存期必须是确定的，缺乏灵活性。

#### 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
- 不会，而是在下一次垃圾回收时才会释放其占用的内存。

#### Class.forName()和ClassLoader.loadClass()区别？
- Class.forName() 默认执行类加载和初始化动作，静态变量会初始化，静态代码块会被执行。
- ClassLoader.loadClass() 默认只执行类加载过程。

#### 异常
> Throwable有两个子类：Error和Exception  
> throw是用来抛出异常的，throws用来标明该函数可能抛出的各种异常。  

- Error（错误）:指程序无法恢复的异常情况，属于运行应用程序中较严重的问题。
- Exception（异常）:指程序有可能恢复的异常情况，表示程序本身可以处理的异常。
- RuntimeException（运行时异常）：由程序自身的问题导致产生的异常，如NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常，属于不可查异常。
- 非运行时异常：由程序外部的问题引起的异常，如FileNotFoundException。

#### 动态代理与静态代理的区别
- 静态代理是代码中显式指定代理，动态代理是在运行时动态创建对象。
- 对于没有实现接口的类，不能使用动态代理
- Proxy类的代码被固定下来，不会因为业务的逐渐庞大而庞大；
- 代理对象是在程序运行时产生的，而不是编译期；
- 可以实现AOP编程，这是静态代理无法实现的；
- 解耦，如果用在web业务下，可以实现数据层和业务层的分离。
- 动态代理的优势就是实现无侵入式的代码扩展。
- 静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。

#### [抽象类和接口的区别](https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/)
- abstract class 和 interface 在Java语言中都是用来描述一个抽象体。
- 相同点
    - 两者都是抽象类，都不能实例化。
    - 子类都必须要实现已经声明的抽象方法，如果子类是抽象类则不用实现。
- 不同点
    - 关键字不同：extends、implements
    - 抽象类可以有构造器、普通变量、方法体，可以使用各种修饰符
    - 接口默认修饰符public static final，不能使用其它修饰符
- 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
- abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。
- 在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为

